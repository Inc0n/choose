import SwiftUIimport AppKitimport Cocoafunc getInputItems() -> [String] {    let inputData: Data =      FileHandle.standardInput.availableData    return String(decoding: inputData, as: UTF8.self)      .trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)      .components(separatedBy: "\n")}final class Options {    // singleton    static let shared = Options()    var returnsIndex           = false    var underlineDisabled      = false    var returnString           = false    var hexColor               = NSColor.systemBlue    var hexBackgroundColor     = NSColor.systemGray    var fontName               = "Menlo"    var fontSize: Float        = 13.0    var numRows                = 10    var percentWidth           = -1    var initialString          = ""}// https://github.com/onmyway133/blog/issues/620struct AutoFocusTextField: NSViewRepresentable {    @Binding var text: String    let textField = NSTextField()    var onSelector: ((_ commandSelector: Selector) -> Bool)    func makeCoordinator() -> Coordinator { Coordinator(self) }    func makeNSView(context: NSViewRepresentableContext<AutoFocusTextField>) -> NSTextField {        textField.delegate = context.coordinator        textField.focusRingType = .none        textField.isBordered = false        textField.drawsBackground = false        let options = Options.shared        textField.font =          NSFont(name: options.fontName,                 size: CGFloat(options.fontSize)) ??          NSFont.systemFont(ofSize: CGFloat(options.fontSize))        DispatchQueue.main.async { // wait till next event cycle            textField.becomeFirstResponder()        }        return textField    }    func updateNSView(_ nsView: NSTextField,                      context: NSViewRepresentableContext<AutoFocusTextField>) {        nsView.stringValue = text        if let window = nsView.window,           window.firstResponder != nsView        // nsView.acceptsFirstResponder        {            if let textView = window.firstResponder as? NSTextView,               let textField = textView.delegate as? NSTextField,               textField == nsView            {} else {                nsView.becomeFirstResponder()            }        }    }    class Coordinator: NSObject, NSTextFieldDelegate {        var parent: AutoFocusTextField        init(_ autoFocusTextField: AutoFocusTextField) {            self.parent = autoFocusTextField        }        func controlTextDidChange(_ obj: Notification) {            let textField = obj.object as! NSTextField            parent.text = textField.stringValue        }        func control(_ control: NSControl,                     textView: NSTextView,                     doCommandBy commandSelector: Selector) -> Bool {            // debugPrint("selector", commandSelector)            return parent.onSelector(commandSelector)        }    }}let app = NSApplication.sharedvar standardError = FileHandle.standardErrorfunc highlight(_ match: Match) -> Text{    var result = Text("")    let string = match.string,        indices = match.indices    for i in string.indices {        let char = Text(String(string[i]))        result = result +          (indices.contains(i)             ? char.bold()             : char.foregroundColor(.secondary))    }    return result}struct ContentView: View {    let items: [String]    let options = Options.shared    @State var string = Options.shared.initialString    @State var selection: Int! = 0    var matches: [Match] { fuzzyMatch(items, by: string) }    var format: String {        String(format: "%d/%d", selection+1, matches.count)    }    var body: some View {        let font =          Font.custom(options.fontName,                      size: CGFloat(options.fontSize))        // .system(size: CGFloat(options.fontSize))        let onEnter = {            let useString = (matches.first?.string.isEmpty ?? false)              && options.returnString            // debugPrint(useString, string, matches, selection ?? "")            if useString || matches.indices.contains(selection) {                print(useString ? string : matches[selection].string)                app.stop(self)            }        }        let onSelector = { (selector: Selector) -> Bool in            switch selector {            case #selector(NSResponder.moveUp(_:)),                 #selector(NSResponder.insertBacktab(_:)):                if (selection > 0) { selection -= 1 }            case #selector(NSResponder.moveDown(_:)),                 #selector(NSResponder.insertTab(_:)):                if (selection < matches.count) { selection += 1 }            case #selector(NSResponder.cancelOperation(_:)):                if string.isEmpty { app.stop(self) }                else { string = "" }            case #selector(NSResponder.insertNewline(_:)):                onEnter()            default:                NSLog(NSStringFromSelector(selector))                return false            }            return true        }        return VStack(alignment: .center) {            Spacer()            HStack() {                Spacer()                Label {                    Text(format)                    Image(nsImage:                            NSImage(imageLiteralResourceName:                                      NSImage.rightFacingTriangleTemplateName))                } icon: {                } .multilineTextAlignment(.center)                  .foregroundColor(Color.gray)                // .labelStyle(IconOnlyLabelStyle())                Spacer()                AutoFocusTextField(text: $string, onSelector: onSelector)                  .textFieldStyle(PlainTextFieldStyle())                  .font(font)            } .padding(.init(top: 0, leading: 5, bottom: 0, trailing: 5))            ZStack(alignment: .topLeading)            {                List(selection: $selection) {                    ForEach(matches.enumerated().map({ $0 }),                            id: \.offset)                    { index, match in                        highlight(match)                    } .font(font)                } .listStyle(SidebarListStyle())                //   .onTapGesture(count: 1) {                //     print("selected", selection ?? "nil")                // }                // Divider must be here                Divider()            }        } .frame(maxWidth: .infinity, maxHeight: .infinity)          .edgesIgnoringSafeArea(.all)          .onChange(of: string) { [string] newString in              // self.matches = fuzzyMatch(items, by: newString)              self.selection = 0          }    }}@mainclass AppDelegate: NSObject, NSApplicationDelegate {    let window = NSWindow(      contentRect: NSRect(        origin: CGPoint.zero,        size: CGSize(width: 500,                     height: 300)),      styleMask: [.titled, .fullSizeContentView, .borderless],      backing: .buffered,      defer: false)    // , screen: nil    let contentView = ContentView(items: getInputItems())    func applicationDidFinishLaunching(_ notification: Notification) {        // setup the window        window.makeKeyAndOrderFront(false)        window.contentView = NSHostingView(rootView: contentView)        window.titlebarAppearsTransparent = true        window.titleVisibility            = .hidden        window.center() // put window at center        NSApp.setActivationPolicy(.accessory)        NSApp.activate(ignoringOtherApps: true)    }    public static func main() {        let options = Options.shared        let args = CommandLine.arguments        var index = 1 // skip first current file name        while index < args.count {            let arg = args[index]            switch arg {            case "-r", "--return-index":      options.returnsIndex = true            case "-u", "--disable-underline": options.underlineDisabled = true            case "-m", "--return-match": options.returnString = true            case "-c", "--foreground":                if let hexColor = NSColor(hex: args[++index]) {                    options.hexColor = hexColor                } else {                    print("bad hexcolor", to: &standardError)                }            case "-b", "--background":                if let hexColor = NSColor(hex: args[++index]) {                    options.hexBackgroundColor = hexColor                } else {                    print("bad hex bg color", to: &standardError)                }            case "-f", "--font-name":                options.fontName = args[++index]            case "-s", "--font-size":                options.fontSize = Float(args[++index]) ?? options.fontSize            case "-n", "--max-rows":                options.numRows = Int(args[++index]) ?? options.numRows            case "-w", "--width-percent":                options.percentWidth = Int(args[++index]) ?? options.percentWidth            case "-i", "--initial-string":                options.initialString = args[++index]                print(options.initialString)            case "-h", "--help":                print("help")                return            default:                print("error", arg, to: &standardError)            }            index += 1        }        let delegate = AppDelegate()        app.delegate = delegate        app.run()    }}