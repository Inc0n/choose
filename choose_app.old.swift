import SwiftUIimport AppKitimport Cocoa// import Utilstypealias Item = Stringfunc getInputItems() -> [Item] {    let stdinHandle = FileHandle.standardInput    let inputData: Data = stdinHandle.availableData    let inputStrings: String =      NSString      .init(data: inputData, encoding:String.Encoding.utf8.rawValue)!      .trimmingCharacters(in: CharacterSet.whitespacesAndNewlines);    return inputStrings.components(separatedBy: "\n")}struct Options {    // singleton    static let shared = Options()    private init() {        // var options = Options.shared        let args = CommandLine.arguments        var index = 0        while index < args.count {            let arg = args[index]            switch arg {            case "-r", "--return-index":      self.returnsIndex = true            case "-u", "--disable-underline": self.underlineDisabled = true            case "-m", "--return-match": self.returnString = true            case "-c", "--foreground":   self.hexColor = args[++index]            case "-b", "--background":   self.hexBackgroundColor = args[++index]            case "-f", "--font-name":    self.fontName = args[++index]            case "-s", "--font-size":                self.fontSize = Float(args[++index]) ?? self.fontSize            case "-n", "--max-rows":                self.numRows = Int(args[++index]) ?? self.numRows            case "-w", "--width-percent":                self.percentWidth = Int(args[++index]) ?? self.percentWidth            case "-i", "--initial-string":                self.initialString = args[++index]            default:                print("error", arg)            }            index += 1        }    }    var returnsIndex           = false    var underlineDisabled      = false    var returnString           = false    var hexColor               = NSColor.systemBlue.toHexString()    var hexBackgroundColor     = NSColor.systemGray.toHexString()    var fontName               = "Menlo"    var fontSize: Float        = 18.0    var numRows                = 10    var percentWidth           = -1    var initialString          = ""}//https://github.com/onmyway133/blog/issues/620struct AutoFocusTextField: NSViewRepresentable {    @Binding var text: String    @State var onSubmit: (() -> Void)    func makeCoordinator() -> Coordinator {        Coordinator(self)    }    func makeNSView(context: NSViewRepresentableContext<AutoFocusTextField>) -> NSTextField {        let textField = NSTextField()        textField.delegate = context.coordinator        textField.focusRingType = .none        textField.isBordered = false        textField.drawsBackground = false        return textField    }    func updateNSView(_ nsView: NSTextField, context: NSViewRepresentableContext<AutoFocusTextField>) {        nsView.stringValue = text        if let window = nsView.window,           window.firstResponder != nsView,           nsView.acceptsFirstResponder        {            if let textView = window.firstResponder as? NSTextView            {                if let textField = textView.delegate as? NSTextField,                   textField != nsView                {                    nsView.becomeFirstResponder()                }            } else {                nsView.becomeFirstResponder()            }        }    }    class Coordinator: NSObject, NSTextFieldDelegate {        var parent: AutoFocusTextField        init(_ autoFocusTextField: AutoFocusTextField) {            self.parent = autoFocusTextField        }        func controlTextDidChange(_ obj: Notification) {            let textField = obj.object as! NSTextField            parent.text = textField.stringValue        }        // func textDidEndEditing(_ notification: Notification) {        //     self.controlTextDidEndEditing(notification)        // }        func controlTextDidEndEditing(_ notification: Notification) {            let textField = notification.object as! NSTextField            parent.text = textField.stringValue            parent.onSubmit()        }        func textShouldEndEditing(_ textObject: NSText) -> Bool {            return false        }    }}let app = NSApplication.sharedstruct ContentView: View {    @State var choice = ""    @State var selection: String? = nil    var items: [Item] = []    func filter(items: [Item], choice: String) -> [Item] {        return choice.isEmpty ? items : items.filter { item in             fuzzy(search: choice, haystack: item)        }    }    var body: some View {        let filtered: [Item] = self.filter(items: items, choice: choice)        let onSubmit = {            let filtered = self.filter(items: items, choice: choice)            if filtered.count == 0                 || filtered[0].isEmpty {                print(choice)            } else { print(filtered[0]) }            NSApp.terminate(app)        }        return VStack(alignment: .center) {            Spacer()            HStack() {                Spacer()                Text("Lightning")                  .multilineTextAlignment(.center)                  .foregroundColor(Color.gray)                Spacer()                AutoFocusTextField(text: $choice, onSubmit: onSubmit)                  .textFieldStyle(PlainTextFieldStyle())                  // .padding(.top, 10)                  .padding(.trailing)            }            Divider()            List(filtered, id: \.self, selection: $selection) {                Text($0)            } .listStyle(PlainListStyle())              .background(Color.clear)        } .frame(maxWidth: .infinity, maxHeight: .infinity)          .edgesIgnoringSafeArea(.all)    }}@mainstruct Choose: App {    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate    let items = getInputItems()    var body: some Scene {        WindowGroup {            ContentView(items: items)        } .windowToolbarStyle(UnifiedWindowToolbarStyle())          .windowStyle(HiddenTitleBarWindowStyle())    }}class AppDelegate: NSObject, NSApplicationDelegate {    // 7     func applicationDidFinishLaunching(_ notification: Notification) {        NSEvent.addLocalMonitorForEvents(matching: .keyDown, handler: keyDown)        let app = notification.object as! NSApplication        // let window = app.mainWindow ?? app.keyWindow ?? app.windows[0]        NSApp.setActivationPolicy(.regular)        NSApp.activate(ignoringOtherApps: false)    }    func keyDown(event: NSEvent) -> NSEvent {        // NSLog("key down is ", event.keyCode, event.characters ?? "nil");        // esc        if event.keyCode == 53 {            NSApp.terminate(self)        }        return event    }    func applicationShouldTerminateAfterLastWindowClosed(        _ sender: NSApplication) -> Bool {        return true    }}